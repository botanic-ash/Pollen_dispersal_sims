col_letter1 <- all_combos[colnames(all_combos) == letter1]
n_letter1 <- sum(all_combos$num[all_combos$col_letter1 == letter1])
n_capital1 <- total - n_letter1
p_letter1 <- n_letter1/total
p_capital1 <- n_capital1/total
col_letter2 <- all_combos[colnames(all_combos) == letter2]
n_letter2 <- sum(all_combos$num[all_combos$col_letter2 == letter2])
n_capital2 <- total - n_letter2
p_letter2 <- n_letter2/total
p_capital2 <- n_capital2/total
n_both <- sum(all_combos$num[all_combos$letter1 == letter1 & all_combos$col_letter2 == letter2])
p_both <- n_both/total
D_both <- p_both - (p_letter1*p_letter2)
D_2 = D_both^2
r_2 = D_2/(p_letter1*p_capital1*p_letter2*p_capital2)
return(r_2)
}
r_2("a", "c")
letter1 <- "a"
letter2 <- "c"
col_letter1 <- all_combos[colnames(all_combos) == letter1]
col_letter1
e
n_letter1 <- sum(all_combos$num[all_combos$col_letter1 == letter1])
n_letter1
sum(all_combos$num[all_combos$col_letter1 == letter1]
)
all_combos$num[all_combos$col_letter1 ==
"a"
]
all_combos$col_letter1
col_letter1
col_letter1
all_combos$num[all_combos[col_letter1 == letter1,
]
)
all_combos$num[all_combos[col_letter1 == letter1,]]
col_letter1
all_combos[colnames(all_combos) == letter1]
]
all_combos$num[all_combos[colnames(all_combos) == letter1]]
all_combos[colnames(all_combos) == letter1]
all_combos[colnames(all_combos) == letter1] == letter1
subset(all_combos[colnames(all_combos) == letter1], letter1)
subset(all_combos[colnames(all_combos) == letter1] == letter1)
subset(all_combos[colnames(all_combos) == letter1])
all_combos$num[all_combos$a
]
all_combos$num[all_combos$a == "a"]
all_combos$a == "a"
all_combos[colnames(all_combos) == letter1]
all_combos[colnames(all_combos) == letter1] == letter1
col_letter1 <- all_combos[colnames(all_combos) == letter1] == letter1
all_combos$num[col_letter1]
r_2 <- function(letter1, letter2){
col_letter1 <- all_combos[colnames(all_combos) == letter1] == letter1
n_letter1 <- sum(all_combos$num[col_letter1])
n_capital1 <- total - n_letter1
p_letter1 <- n_letter1/total
p_capital1 <- n_capital1/total
col_letter2 <- all_combos[colnames(all_combos) == letter2] == letter2
n_letter2 <- sum(all_combos$num[col_letter2])
n_capital2 <- total - n_letter2
p_letter2 <- n_letter2/total
p_capital2 <- n_capital2/total
n_both <- sum(all_combos$num[all_combos$letter1 == letter1 & all_combos$col_letter2 == letter2])
p_both <- n_both/total
D_both <- p_both - (p_letter1*p_letter2)
D_2 = D_both^2
r_2 = D_2/(p_letter1*p_capital1*p_letter2*p_capital2)
return(r_2)
}
r_2("a", "c")
r_2("a", "b")
r_2("b", "c")
?sample
G_t <- matrox(nrow = 2, ncol = 1)
G_t[1,1] <- t
G_t <- matrix(nrow = 2, ncol = 1)
G_t[1,1] <- t
t
t = 0
G_t[1,1] <- t
G_t[1,1]
G_t
G_t[2,1] <- k
G_t[2,1] <- k
n = 10
k = n
G_t[2,1] <- k
G_t
G_t <- matrix(nrow = 2, ncol = 1)
G_t[1,1] <- t
G_t[2,1] <- k
G_t
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
n = 10
L = 200
rho = .02
k = n
t = 0
G_t <- matrix(nrow = 2, ncol = 1)
G_t[1,1] <- t
G_t[2,1] <- k
G_t
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t_waiting_for_event
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
event
sample(1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
}
else(event == "recomb"){
if(event == "coalescence"){
k = k - 1
}
else(event == "recomb"){
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
event
if(event == "coalescence"){
k = k - 1
}
else if(event == "recomb"){
if(event == "coalescence"){
k = k - 1
}
else if(event == "recomb"){
next_event <- c(t, k)
next_event
k = n
while(k > 1){
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
}
else if(event == "recomb"){
k = k + 1
}
next_event <- c(t, k)
cbind(G_t, next_event)
}
View(G_t)
event
k
G_t[1,1] <- t
G_t[1,2] <- k
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
G_t
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
G_t
k = n
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
G_t
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
event
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
k
next_event <- c(t, k)
next_event
rbind(G_t, next_event)
n = 10
L = 200
rho = .02
G_t
trajectory <- list[length(num_trajectories)]
num_trajectories = 1000
trajectory <- list[length(num_trajectories)]
?list
trajectory <- vector("list", num_trajectories)
trajectory
trajectory <- vector("list", num_trajectories)
for (i in 1:num_trajectories){
k = n
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
while(k != 1){
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
rbind(G_t, c(t, k))
}
trajectory[[i]] <- G_t
}
n = 10
L = 200
rho = .02
num_trajectories = 1000
trajectory <- vector("list", num_trajectories)
for (i in 1:num_trajectories){
k = n
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
while(k != 1){
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
rbind(G_t, c(t, k))
}
trajectory[[i]] <- G_t
}
G_t
k
n = 10
L = 200
rho = .02
num_trajectories = 1000
trajectory <- vector("list", num_trajectories)
k = n
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
while(k != 1){
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
rbind(G_t, c(t, k))
}
i = 1
trajectory[[i]] <- G_t
G_t
G_t
k
k = n
t = 0
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
c(t, k)
rbind(G_t, c(t, k))
trajectory <- vector("list", num_trajectories)
n = 10
L = 200
rho = .02
num_trajectories = 1000
trajectory <- vector("list", num_trajectories)
for (i in 1:num_trajectories){
k = n
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
while(k != 1){
t_waiting_for_event <- rexp(1, ((k * rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = ((k * rho/2)*(L-1))/ (((k * rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ (((k * rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
G_t <- rbind(G_t, c(t, k))
}
trajectory[[i]] <- G_t
}
set.seed(2023)
tail(trajectory[[]], n = 1)[1, ] >= 20
trajectory
tail(trajectory[[1:num_trajectories]], n = 1)[1, ] >= 20
trajectory[[1:num_trajectories]]
trajectory[[c(1:num_trajectories)]]
i = 1
tail(trajectory[[i]], n = 1)[1, ] >= 20
tail(trajectory[[i]], n = 1)[1, ]
tail(trajectory[[i]], n = 1)[, 1]
tail(trajectory[[i]], n = 1)
tail(trajectory[[i]], n = 1)[1,]
tail(trajectory[[i]], n = 1) >= 20
tail(trajectory[[i]], n = 1) >= 20[1,]
true_false <- matrix(nrow = 1, ncol = 2)
true_false <- matrix(nrow = 1, ncol = 2)
for (i in 1:num_trajectories){
answer <- tail(trajectory[[i]], n = 1) >= 20
cbind(true_false, answer)
}
View(true_false)
true_false <- matrix(nrow = 1, ncol = 2)
for (i in 1:num_trajectories){
answer <- tail(trajectory[[i]], n = 1) >= 20
rbind(true_false, answer)
}
true_false <- matrix(nrow = 1, ncol = 2)
true_false
tail(trajectory[[i]], n = 1) >= 20
answer
_
true_false <- matrix(nrow = 1, ncol = 2)
for (i in 1:num_trajectories){
answer <- tail(trajectory[[i]], n = 1) >= 20
true_false <- rbind(true_false, answer)
}
trajectory
true_false
true_false[-1, 1]
sum(true_false[-1, 1])
num_trajectories - sum(true_false[-1, 1])
View(trajectory)
times <- matrix(nrow = 1, ncol = 2)
end_times <- matrix(nrow = 1, ncol = 2)
for (i in 1:num_trajectories){
last_time <- tail(trajectory[[i]], n = 1)
end_times <- rbind(end_times,last_time)
}
hist(end_times[-1, 1])
prob_co
prob_recom
k
k = 10
prob_co = ((k * rho/2)*(L-1))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * rho/2)/ ((k * (rho/2)*(L-1)) + choose(k, 2))
prob_co
prob_recom
prob_co = ((k * (rho/2))*(L-1))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * (rho/2))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
b
prob_co = (choose(k, 2))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * (rho/2)*(L-1))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
prob_co
prob_recom
set.seed(2023)
n = 10
L = 200
rho = .02
num_trajectories = 1000
trajectory <- vector("list", num_trajectories)
for (i in 1:num_trajectories){
k = n
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
while(k != 1){
t_waiting_for_event <- rexp(1, (k * (rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = (choose(k, 2))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * (rho/2)*(L-1))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
G_t <- rbind(G_t, c(t, k))
}
trajectory[[i]] <- G_t
}
for (i in 1:num_trajectories){
k = n
t = 0
G_t <- matrix(ncol = 2, nrow = 1)
G_t[1,1] <- t
G_t[1,2] <- k
while(k != 1){
t_waiting_for_event <- rexp(1, (k * (rho/2)*(L-1)) +  choose(k, 2))
t = t + t_waiting_for_event
prob_co = (choose(k, 2))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
prob_recom = (k * (rho/2)*(L-1))/ ((k * (rho/2)*(L-1)) + choose(k, 2))
event <- sample(size = 1, c("coalescence", "recomb"), prob = c(prob_co, prob_recom))
if(event == "coalescence"){
k = k - 1
} else if(event == "recomb"){
k = k + 1
}
G_t <- rbind(G_t, c(t, k))
}
trajectory[[i]] <- G_t
}
end_times <- matrix(nrow = 1, ncol = 2)
for (i in 1:num_trajectories){
last_time <- tail(trajectory[[i]], n = 1)
end_times <- rbind(end_times,last_time)
}
hist(end_times[-1, 1])
hist(end_times[-1, 1], breaks = 50)
hist(end_times[-1, 1], breaks = 50, ylab = "TMRCA", main = "TMRCA across 1000 trajectories")
hist(end_times[-1, 1], breaks = 50, xlab = "TMRCA", main = "TMRCA across 1000 trajectories")
hist(end_times[-1, 1], breaks = 50, xlab = "Time to MRCA", main = "Time to MRCA across 1000 trajectories")
num_trajectories - sum(end_times[-1, 1] >= 20)
end_times[-1, 1] >= 20
end_times[-1, 1]
sum(end_times[-1, 1] >= 20)
num_trajectories - sum(end_times[-1, 1] >= 20)
plot(y = sigma_2, x = c(0:50))
sigma_2 <- (rho + 10)/(rho^2 + 13*rho + 22)
plot(y = sigma_2, x = c(0:50))
sigma_2 <- (rho + 10)/(rho^2 + 13*rho + 22)
rho <- seq(0:50, by = .1)
plot(y = sigma_2, x = rho, type = "l")
rho <- seq(0:50, by = .1)
sigma_2 <- (rho + 10)/(rho^2 + 13*rho + 22)
rho <- seq(from = 0, to = 50, by = .1)
plot(y = sigma_2, x = rho, type = "l")
sigma_2
sigma_2 <- function(tho){
return((rho + 10)/(rho^2 + 13*rho + 22))
}
rho <- seq(from = 0, to = 50, by = .1)
plot(y = sigma_2, x = rho, type = "l")
sigma_2 <- function(tho){
return((rho + 10)/(rho^2 + 13*rho + 22))
}
i
sigma_2 <- function(rho){
return((rho + 10)/(rho^2 + 13*rho + 22))
}
curve(sigma_2, from = 0, to = 50)
sigma_2(0)
sigma_2(0) * .05
five_perc_rho_0 <- sigma_2(0) * .05
five_perc_rho_0
c(five_perc_rho_0, five_perc_rho_0*13 -1, five_perc_rho_0*22 - 10)
five_perc_rho_0 <- sigma_2(0) * .05
result(five_perc_rho_0, five_perc_rho_0*13 -1, five_perc_rho_0*22 - 10)
# Constructing Quadratic Formula
result <- function(a,b,c){
if(delta(a,b,c) > 0){ # first case D>0
x_1 = (-b+sqrt(delta(a,b,c)))/(2*a)
x_2 = (-b-sqrt(delta(a,b,c)))/(2*a)
result = c(x_1,x_2)
}
else if(delta(a,b,c) == 0){ # second case D=0
x = -b/(2*a)
}
else {"There are no real roots."} # third case D<0
}
# Constructing delta
delta<-function(a,b,c){
b^2-4*a*c
}
five_perc_rho_0 <- sigma_2(0) * .05
result(five_perc_rho_0, five_perc_rho_0*13 -1, five_perc_rho_0*22 - 10)
result
roots <- result(five_perc_rho_0, five_perc_rho_0*13 -1, five_perc_rho_0*22 - 10)
roots
roots[roots > 0]
N_e= 10000
r = 1.25 * (10^-8)
rho = 4*N_e*r
rho
five_perc_rho_0
five_perc_rho_0 /4*N_e
five_perc_rho_0 /4*N_e*r
five_perc_rho_0 /(4*N_e*r)
1.25 * (10^-8)
five_perc_rho_0
rho_root <- roots[roots > 0]
rho_root /(4*N_e*r)
curve(sigma_2, from = 0, to = 50, xlab = "Rho", ylab = "Sigma^2")
